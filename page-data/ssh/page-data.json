{"componentChunkName":"component---src-templates-lesson-template-js","path":"/ssh","result":{"data":{"markdownRemark":{"html":"<p>One of the most key things you need to take away from this workshop is how to remotely connect to a server and run commands on it. This is one of the times you absolutely must know your way around bash or you'll be out of look because there's no other way how to do it.</p>\n<h2 id=\"when-would-you-do-this\" style=\"position:relative;\"><a href=\"#when-would-you-do-this\" aria-label=\"when would you do this permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>When would you do this</h2>\n<p>One of the easiest things to do is to get a VM (virtual machine) up and running in the cloud. So many companies offer this like Azure, DigitalOcean, AWS, Linode, etc. A VM is literally just a Linux machine running somewhere in the cloud. Many times the only real way to administrate and run code on these servers is just to connect into a remote CLI session and run the code yourself. It's also very easy with your newly learned skills! Let's see how to do that.</p>\n<h2 id=\"get-a-second-vm-running\" style=\"position:relative;\"><a href=\"#get-a-second-vm-running\" aria-label=\"get a second vm running permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Get a second VM running</h2>\n<p>I'm assuming here you're using Multipass. If not you'll have to figure out how to get a second VM running yourself.</p>\n<p>If you're running macOS, open a new terminal that's running locally for macOS. You can do that by right clicking on the Terminal icon in your dock and clicking New Window.</p>\n<p>If you're running Windows, open your start menu and search for PowerShell and open a window for that.</p>\n<p>If you're running Linux, just run this directly in a host context of your Linux machine, not inside your Multipass VM.</p>\n<p>Run this command (it's multipass specific so you don't really need to care what it does or how it works, it's just useful here.)</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">multipass launch --name secondary</code></pre></div>\n<p>This will launch a second Linux VM named secondary (by default the first one was named primary.) This will take a second to start. Once it does you can type <code class=\"language-text\">multipass shell secondary</code>. You can also do it from the Multipass icon as well. This one will be identical to the first one but it's a whole separate VM so it won't have all the stuff from your first one in there. You'll also notice that when you log in it'll say <code class=\"language-text\">ubuntu@secondary</code> in your prompt instead of <code class=\"language-text\">ubuntu@primary</code>.</p>\n<p>On the secondary, let's make a new user. Run the following</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">useradd</span> -s /bin/bash -m -g ubuntu brian\n<span class=\"token function\">sudo</span> <span class=\"token function\">passwd</span> brian <span class=\"token comment\"># something simple, like asdf</span></code></pre></div>\n<p>This will create a new user with bash as their default shell (the <code class=\"language-text\">-s</code> part) with a premade home directory (the <code class=\"language-text\">-m</code> part), and they'll be apart of the ubuntu group (the <code class=\"language-text\">-g</code> part.) Now we'll make it so we can connect to the secondary as brian from the primary.</p>\n<h2 id=\"ssh-keys\" style=\"position:relative;\"><a href=\"#ssh-keys\" aria-label=\"ssh keys permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SSH Keys</h2>\n<p>The next thing we need to do is to create ssh keys for primary. The ssh key on primary is how it's going to identify itself to secondary. I'm not going to explain how ssh keys work (it's a lot of complicated math) but the basic gist is this: when you generate a new ssh key, you get two files, a public key and a private key. The public key is what you give to everyone else and is not a secret. You're basically giving them a key hole and telling them to install it on a door for you. The private key is just that, your private key. You will <em>never</em> reveal this key to anyone. If anyone does get ahold of this key they can freely masquerade as you. This is the key to the key hole. If you do accidentally reveal your private key ever, you should immediately stop using it and make a new one.</p>\n<p>If you want to dig a bit deeper, check out the Wikipedia page on <a href=\"https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange\">Diffie-Hellman key exchange</a>. Fascinating history. This isn't the same as what ssh uses but rather the first sort of public key encryption that existed.</p>\n<p>So, on the primary, let's generate our public key. Run this:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">ssh-keygen -t rsa\n<span class=\"token comment\"># hit enter to put the key files in the default place</span>\n<span class=\"token comment\"># hit enter to give an empty passphrase</span>\n<span class=\"token comment\"># hit enter again to confirm</span></code></pre></div>\n<p>Here we're generating a new random key. This key is essentially unguessable and therefore unless something unreal happens, is unhackable from a brute force perspective. We're telling it to put everything in the <code class=\"language-text\">~/.ssh</code> directory which is standard. Lastly we're electing to not give it a passphrase. In general it's a good idea to give it a passphrase so that anytime you use the SSH key you need to enter a passphrase (and frequently you can save a passkey to something like macOS's keychain) but in this case we're okay to skip it in the name of a demo.</p>\n<h2 id=\"connecting-to-secondary\" style=\"position:relative;\"><a href=\"#connecting-to-secondary\" aria-label=\"connecting to secondary permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Connecting to secondary</h2>\n<p>If you run <code class=\"language-text\">ls ~/.ssh</code> you'll at least see id<em>rsa (your private key) and id</em>rsa.pub (your public key.) These are ready to go to be used. We're going to use these allow ubuntu@primary to connect to brian@secondary. Run <code class=\"language-text\">cat ~/.ssh/id_rsa.pub</code> and copy the output onto your clipboard.</p>\n<p>Change now to your secondary machine.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">su</span> brian\n<span class=\"token function\">mkdir</span> ~/.ssh\n<span class=\"token function\">vi</span> ~/.ssh/authorized_keys <span class=\"token comment\"># paste in copied ssh id_rsa.pub from primary, write, and quit</span>\n<span class=\"token function\">chmod</span> <span class=\"token number\">700</span> ~/.ssh\n<span class=\"token function\">chmod</span> <span class=\"token number\">600</span> ~/.ssh/authorized_keys</code></pre></div>\n<p>Note: you typically won't have to do this yourself. With someone like Azure or DigitalOcean, you'll give them your id<em>rsa.pub and they'll take care of making sure it gets into authorized</em>keys. You'll just have to generate it and give it to them.</p>\n<p>Lastly, we're going to need to give <code class=\"language-text\">ssh</code> an address to connect to. Just like you need an address to mail a letter to, you need an IP address to tell your computer where to connect to. Let's go grab that. Run the command <code class=\"language-text\">ifconfig</code>. This is going to dump out a bunch of addresses and hashes.</p>\n<p>You're looking for numbers like look this: <code class=\"language-text\">X.X.X.X</code>.</p>\n<p>For sure one of them will be 127.0.0.1. That's not it. That's called the loopback: a network address that refers to the same machine. Connecting to that would be like mailing a letter to yourself. Try <code class=\"language-text\">ping 127.0.0.1</code>. This will send little packets of data to that address and see if it responds. It'd be like looking in a mirror and saying \"hey you there?\"</p>\n<p>Ignore the mask and broadcast. Look for an inet one that looks like <code class=\"language-text\">192.168.64.3</code> or close to it. That's the one you're looking for. That's what the address of this secondary machine to broader network (in this case, this network is just local to your computer.) If you want to make sure it works, try <code class=\"language-text\">ping 192.168.64.3</code> and see if it responds with data. If it says it's unreachable you picked the wrong one.</p>\n<p>Okay! Now we're ready to connect from primary. Head back there and type this:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">ssh</span> brian@<span class=\"token operator\">&lt;</span>the <span class=\"token function\">ip</span> address you just got from <span class=\"token function\">ifconfig</span> on the other machine<span class=\"token operator\">></span></code></pre></div>\n<p>You should connect! The primary machine is now connect via ssh to the secondary machine and now remotely running commands on it. Why is this a big deal? In this specific case it's not because we can just use Multipass to open a shell but it is a big deal because we can use this same process to connect to <em>any machine</em>. You can say <code class=\"language-text\">ssh brian@&lt;my vm in the cloud&gt;</code> and it works the same way! Now you can remotely connect to your server in the cloud or your Raspberry Pi in the other room. It works with any Linux machine you can connect to over the network.</p>","frontmatter":{"path":"/ssh","title":"SSH","order":"7A","section":"Networking and the Internet","description":"One of the most key things a developer needs to know how to do is connect to a remote server and run commands on it. In this section Brian shows you how to set up a second VM so you can remotely connect via ssh into it from the first one."}},"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"order":"3A","path":"/anatomy-of-a-cli-command","title":"Anatomy of a CLI Command"}}},{"node":{"frontmatter":{"order":"6A","path":"/environments","title":"Environments"}}},{"node":{"frontmatter":{"order":"5A","path":"/interacting-with-files","title":"Interacting with Files"}}},{"node":{"frontmatter":{"order":"1A","path":"/intro","title":"Introduction"}}},{"node":{"frontmatter":{"order":"2C","path":"/lets-run-linux","title":"Let's Run Linux"}}},{"node":{"frontmatter":{"order":"4A","path":"/nano","title":"nano"}}},{"node":{"frontmatter":{"order":"6D","path":"/process-operators","title":"Exit Codes, Process Operators, and Subcommands"}}},{"node":{"frontmatter":{"order":"6B","path":"/processes","title":"Processes"}}},{"node":{"frontmatter":{"order":"7B","path":"/sftp","title":"SFTP"}}},{"node":{"frontmatter":{"order":"3C","path":"/signals-and-the-power-of-ctrl","title":"Signals and the the Power of CTRL"}}},{"node":{"frontmatter":{"order":"7A","path":"/ssh","title":"SSH"}}},{"node":{"frontmatter":{"order":"5C","path":"/streams-and-pipes","title":"Streams and Pipes"}}},{"node":{"frontmatter":{"order":"3B","path":"/common-tips-and-tricks","title":"Common Tips and Tricks"}}},{"node":{"frontmatter":{"order":"5D","path":"/users-groups-and-permissions","title":"Users, Groups, and Permissions"}}},{"node":{"frontmatter":{"order":"4B","path":"/vim","title":"vim"}}},{"node":{"frontmatter":{"order":"2B","path":"/what-is-linux","title":"What is Linux"}}},{"node":{"frontmatter":{"order":"2A","path":"/what-will-you-learn","title":"What you will learn"}}},{"node":{"frontmatter":{"order":"5B","path":"/lol","title":"Wildcards and Replacements"}}}]}},"pageContext":{}}}