{"componentChunkName":"component---src-templates-lesson-template-js","path":"/streams-and-pipes","result":{"data":{"markdownRemark":{"html":"<p>Linux has an interesting concept where basically all input and output (which are text) are actually streams of data/text. Like plumbing pipes where you can connect and disconnect sections to redirect water to different places, so too can you connect and disconnect streams of data.</p>\n<h1 id=\"the-standard-streams\" style=\"position:relative;\"><a href=\"#the-standard-streams\" aria-label=\"the standard streams permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>The Standard Streams</h1>\n<p>There are three standard streams, stdin (said standard input or standard in,) stdout (said standard output or standard out,) and stderr (said standard error or standard err.) stdin is an input stream to a program and the other two are output streams. stdout for all non-error text, the normal output. stderr is just for error information.</p>\n<h2 id=\"stdout\" style=\"position:relative;\"><a href=\"#stdout\" aria-label=\"stdout permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>stdout</h2>\n<p>stdout is where all normal output goes. If it's not caught or redirected, stdout by default goes to your terminal screen (as does stderr too.) A good example of that is our friend cat. cat take a file and concatenates it to the stdout. If you do <code class=\"language-text\">cat file1.txt</code> and don't redirect that stream somewhere else, it ends up at the terminal screen and you get the ouptut of the file. What if we wanted to redirect the output? We can!</p>\n<p>Try this.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"this will get output to the file and not to stdout\"</span> <span class=\"token operator\"><span class=\"token file-descriptor important\">1</span>></span> new-file.txt</code></pre></div>\n<p>The <code class=\"language-text\">1&gt;</code> redirect stdout from heading to the terminal and into a file, new-file.txt. We don't see the output of echo; it's been redirected. So what if we wanted to do that to cat?</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">cat</span> new-file.txt <span class=\"token operator\"><span class=\"token file-descriptor important\">1</span>></span> yet-new-file.txt</code></pre></div>\n<p>What do you think happened here? We concatenated new-file.txt to stdout and then redirected stdout to a file. So basically we did <code class=\"language-text\">cp</code> with more steps and concepts. But hey! Now you can see the power of piping stdout to different places.</p>\n<h2 id=\"replacing-vs-appending\" style=\"position:relative;\"><a href=\"#replacing-vs-appending\" aria-label=\"replacing vs appending permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Replacing vs appending</h2>\n<p>So far we've been replacing files with <code class=\"language-text\">1&gt;</code>. What if we want to append? That is to say, instead of replacing the file's contents, we just want to add new stuff to the end? That's where <code class=\"language-text\">1&gt;&gt;</code> comes in (this will work with all streams, not just 1 / stdout.)</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">ls</span> -lsah <span class=\"token operator\"><span class=\"token file-descriptor important\">1</span>></span> ls.txt\n<span class=\"token function\">ls</span> -lsah <span class=\"token operator\"><span class=\"token file-descriptor important\">1</span>>></span> ls.txt</code></pre></div>\n<p>What would you expect the output of ls.txt to be now? It's two outputs of <code class=\"language-text\">ls -lsah</code>.</p>\n<h2 id=\"stderr\" style=\"position:relative;\"><a href=\"#stderr\" aria-label=\"stderr permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>stderr</h2>\n<p>So let's talk about the other output stream, stderr. While <code class=\"language-text\">1&gt;</code> redirects stdout, <code class=\"language-text\">2&gt;</code> redirect stderr. So if I say <code class=\"language-text\">ls -lsah 2&gt; error-log.txt</code> what would you expect to happen? You'll see the normal output of stdout to the terminal since we didn't redirect it and it will create a new file called error-log.txt with nothing in it.</p>\n<p>Okay, so let's do something that causes an error then. Run <code class=\"language-text\">cat file-that-doesnt-exist.txt 2&gt; error-log.txt</code>. So what happens here? Nothing gets output since nothing is concatenated to stdout (since that file doesn't exist) and <code class=\"language-text\">cat: file-that-doesnt-exist.txt: No such file or directory</code> gets output to error-log.txt.</p>\n<p>All the same things apply too with <code class=\"language-text\">2&gt;</code> for replacing a file and <code class=\"language-text\">2&gt;&gt;</code> for appending.</p>\n<p>Note, so far everything we've done has had either error information or normal info and not both. Normally it'll have both.</p>\n<h2 id=\"redirecting-both-stderr-and-stdout\" style=\"position:relative;\"><a href=\"#redirecting-both-stderr-and-stdout\" aria-label=\"redirecting both stderr and stdout permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Redirecting both stderr and stdout</h2>\n<p>Okay so now we want to redirect both stderr and stdout. Easy</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">ls</span> -lsah <span class=\"token operator\"><span class=\"token file-descriptor important\">1</span>></span> stdout.txt <span class=\"token operator\"><span class=\"token file-descriptor important\">2</span>></span> stderr.txt</code></pre></div>\n<p>This will redirect each of those streams to different files.</p>\n<p>We can have them go to the same file too!</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">ls</span> -lsah <span class=\"token operator\"><span class=\"token file-descriptor important\">1</span>></span> ls.txt <span class=\"token operator\"><span class=\"token file-descriptor important\">2</span>></span> ls.txt</code></pre></div>\n<p>Or, even more easily,</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">ls</span> -lsah <span class=\"token operator\">></span> ls.txt</code></pre></div>\n<p>Yes, if you put no number there, it will output <em>both</em> streams to the same file. Honestly this is what I normally do unless I'm keeping track of an error log separately (like I would on a production machine) but for just every day stuff, this is normally what I'd do. <code class=\"language-text\">&gt;&gt;</code> will work too for appending.</p>\n<h2 id=\"devnull\" style=\"position:relative;\"><a href=\"#devnull\" aria-label=\"devnull permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>/dev/null</h2>\n<p>Sometimes you want to run a program and you don't really care what the output is; you just want to run the program. Say hello to <code class=\"language-text\">/dev/null</code> which is the programming equivalent of the infinite abyss. Anything that gets output to /dev/null is thrown away. Let's say you're running a program that's very noisy and you really only care if there's an error.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">ls</span> -lsah <span class=\"token operator\"><span class=\"token file-descriptor important\">1</span>></span> /dev/null <span class=\"token comment\"># assume this is a very noisy program</span></code></pre></div>\n<p>This will run the command and only print the errors. Everything else gets chucked into the infinite abyss. Useful sometimes</p>\n<h2 id=\"stdin\" style=\"position:relative;\"><a href=\"#stdin\" aria-label=\"stdin permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>stdin</h2>\n<p>Okay, so now we've talked exhaustively about the output streams, let's chat a minute about input streams.</p>\n<p>stderr and stdout direct the text from a program to a file. With stdin, we can direct the contents of a file into a program via the stdin. Try this</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">cat</span> <span class=\"token operator\">&lt;</span> ls.txt</code></pre></div>\n<p>Now, again, not entirely useful, since <code class=\"language-text\">cat &lt; ls.txt</code> would have done the same thing. But let's say it's a very long file and we want to find one very specific line. We could do this:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">grep</span> <span class=\"token string\">\"error-log.txt\"</span> <span class=\"token operator\">&lt;</span> ls.txt</code></pre></div>\n<p>We'll talk about the ins and outs of grep in a later chapter but for now it's enough to know it lets you find things in a text stream. In this case, we took the contents of <code class=\"language-text\">ls.txt</code> and connected that stream to grep which grep then looked for a line that contained \"error-log.txt\" in it. So that's what <code class=\"language-text\">&lt;</code> does, it take a file and puts that into stdin so a program can use it.</p>\n<h2 id=\"using-stdin-and-stdout\" style=\"position:relative;\"><a href=\"#using-stdin-and-stdout\" aria-label=\"using stdin and stdout permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Using stdin and stdout</h2>\n<p>What if we want to have both stdin and stdout and then throw away the errors?</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">grep</span> <span class=\"token string\">\"error-log.txt\"</span> <span class=\"token operator\">&lt;</span> ls.txt <span class=\"token operator\"><span class=\"token file-descriptor important\">1</span>></span> ls2.txt <span class=\"token operator\"><span class=\"token file-descriptor important\">2</span>></span> /dev/null</code></pre></div>\n<p>Just like that! Order isn't important.</p>\n<h2 id=\"why\" style=\"position:relative;\"><a href=\"#why\" aria-label=\"why permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Why?</h2>\n<p>Hopefully by now you understand how this works but you may be asking why? All these examples seem contrived and so far they have been. But when you start running commands yourself you'll find that a lot of the times you need to keep track of what happens. A good example is if I'm running a web server from a computer: I want the output from the server (like who logged in, anayltics, metrics, security stuff, etc.) to live in one place so I can keep track of the logs and I want the error logs to live in another place so I can debug successfully what's going on with my server. In this case, stderr and stdout are <em>very</em> useful. What if I need to to input some secrets like passwords and cache keys to a server in order to start it up? stdin is definitely one way to do that.</p>\n<h2 id=\"pipes\" style=\"position:relative;\"><a href=\"#pipes\" aria-label=\"pipes permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Pipes</h2>\n<p>Okay so we've exhausted you can do with just files but what if we want to use the output of one program into another? Enter the pipe (sometimes called vertical bar,) <code class=\"language-text\">|</code>. This takes what one program outputs and puts it into the next one. This opens up a lot of possibilites. Let's redo that one we had above with grep using cat and |.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">cat</span> ls.txt <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> <span class=\"token string\">\"error-log.txt\"</span></code></pre></div>\n<p>cat will concatentate ls.txt to stdout and then <code class=\"language-text\">|</code> will take the output of that and run that as stdin to grep.</p>\n<p>Let's try another using ps. We'll get to processes later but ps outputs all running processes. It's usually a very long list since Linux has a lot running all the time. Try running <code class=\"language-text\">ps aux</code> and see how long it is. It can be much longer too if you're running a server. Notice the last thing it outputs is the <code class=\"language-text\">ps aux</code> command itself that you used to find it. Let's use grep to find just that line and nothing else. Try this:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">ps</span> aux <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> <span class=\"token string\">\"ps aux\"</span></code></pre></div>\n<p>This should output two lines, the <code class=\"language-text\">ps aux</code> call and the <code class=\"language-text\">grep</code> we're running to find that ps aux. A little self referential but the point here is that we're able to find just what we need and leave the rest behind. And we're doing that with the power of pipes. <code class=\"language-text\">ps aux</code> find all processes and outputs that to stdout. We then take that stdout and run that as the stdin to grep. grep then finds just the lines it needs and outputs just those to its stdout. At this point we don't have anything else redirecting output streams so it gets output to the terminal window. We absolutely could redirect that out to a file using <code class=\"language-text\">1&gt;</code>.</p>\n<p>Let's a bit trickier one. If you do <code class=\"language-text\">rm -i *.txt</code>, it'll try to remove all files with .txt extensions. It'll all confirm with you on each one to say either y for yes or n for no. Try it and say \"n\" and hit enter for each one. Notice afterwards you won't have deleted anything.</p>\n<p>Lots of Linux programs function this way of answering y or n questions. Someone got sick of doing it and wrote a program to just answer <code class=\"language-text\">y</code> nonstop called <code class=\"language-text\">yes</code>. We looked at this before. But now let's yes it. Let's make it say n to all those questions.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">yes</span> n <span class=\"token operator\">|</span> <span class=\"token function\">rm</span> -i *.txt</code></pre></div>\n<p>The first command, <code class=\"language-text\">yes n</code> outputs infinite <code class=\"language-text\">n</code>s to stdout. <code class=\"language-text\">rm -i *.txt</code> uses those from stdin to answer <code class=\"language-text\">n</code> to every question it asks. Pretty cool, right?</p>\n<p>We'll use pipes a lot. By this we can use smaller commands like grep, cat, yes, and other to make higher level programs. We're using bash to program! Bash scripting.</p>","frontmatter":{"path":"/streams-and-pipes","title":"Streams and Pipes","order":"5C","section":"Files, Pipes, and Permissions","description":"Linux has an interesting concept called streams. The most common of these are stdout, stderr, and stdin. Brian goes over what streams are and how to pipe them together."}},"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"order":"5A","path":"/interacting-with-files","title":"Interacting with Files"}}},{"node":{"frontmatter":{"order":"3A","path":"/anatomy-of-a-cli-command","title":"Anatomy of a CLI Command"}}},{"node":{"frontmatter":{"order":"1A","path":"/intro","title":"Introduction"}}},{"node":{"frontmatter":{"order":"2C","path":"/lets-run-linux","title":"Let's Run Linux"}}},{"node":{"frontmatter":{"order":"4A","path":"/nano","title":"nano"}}},{"node":{"frontmatter":{"order":"3C","path":"/signals-and-the-power-of-ctrl","title":"Signals and the the Power of CTRL"}}},{"node":{"frontmatter":{"order":"5C","path":"/streams-and-pipes","title":"Streams and Pipes"}}},{"node":{"frontmatter":{"order":"3B","path":"/common-tips-and-tricks","title":"Common Tips and Tricks"}}},{"node":{"frontmatter":{"order":"5D","path":"/users-groups-and-permissions","title":"Users, Groups, and Permissions"}}},{"node":{"frontmatter":{"order":"4B","path":"/vim","title":"vim"}}},{"node":{"frontmatter":{"order":"2B","path":"/what-is-linux","title":"What is Linux"}}},{"node":{"frontmatter":{"order":"2A","path":"/what-will-you-learn","title":"What you will learn"}}},{"node":{"frontmatter":{"order":"5B","path":"/lol","title":"Wildcards and Replacements"}}}]}},"pageContext":{}}}